	|\
====| \
		S	-> Single Responsibility Principle
====| /	
	|/
	
	|\
====| \
		O	-> Open / Closed Principle
====| /	
	|/
	
	|\
====| \
		L	-> Liskov Substitution Principle 
====| /	
	|/
	
	|\
====| \
		I	-> Interface Segregation Principle
====| /	
	|/
	
	|\
====| \
		D	-> Dependency Inversion Principle
====| /	
	|/
	
/***********************	S O L I D  hai Boss		************************/

* In OOP, the term SOLID is a mnemonic acronym for five design principles 
* It is intended to make software designs more understandable flexible and maintainable. 
* SOLID principles forms a core philosophy for methodologies such as Agile Development or Adaptive Software Development

/***************************************************************************/
S	-> Single Responsibility Principle

Single responsibility principle
The single responsibility principle is a computer programming principle that states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility. Robert C. Martin expresses the principle as, "A class should have only one reason to change."
The term was introduced by Robert C. Martin in an article by the same name as part of his Principles of Object Oriented Design,[2] made popular by his book Agile Software Development, Principles, Patterns, and Practices. Martin described it as being based on the principle of cohesion.

Martin defines a responsibility as a reason to change, and concludes that a class or module should have one, and only one, reason to be changed (i.e. rewritten). As an example, consider a module that compiles and prints a report. Imagine such a module can be changed for two reasons. First, the content of the report could change. Second, the format of the report could change. These two things change for very different causes; one substantive, and one cosmetic. The single responsibility principle says that these two aspects of the problem are really two separate responsibilities, and should therefore be in separate classes or modules. It would be a bad design to couple two things that change for different reasons at different times.

##############################################################################
O	-> Open / Closed Principle



##############################################################################
L	-> Liskov Substitution Principle 



##############################################################################
I	-> Interface Segregation Principle

* Make fine grained interfaces that are client 
* Client should not be forced to implement interfaces that they do not use
* In other words, its better to have smaller interfaces, than fewer, fatter interface
* By breaking down interfaces, we are favor COMPOSITION instead of INHERITANCE
* Decoupling over Coupling

Ex : 
Interface Segregation NOT Applied
---------------------------------
interface Animal {
	eat();
	sleep();
	walk();
}

This would mean that we have a MONOLTHIC interface called ANIMAL, 
which would NOT be the perfect ABSTRACTION, because some animals can FLY.

Interface Segregation APPLIED
-----------------------------
Breaking this monolithic interface into smaller interfaced based by ROLE.
 
interface CanEat	{ eat(); } 
interface CanSleep	{ sleep(); } 
interface CanWalk	{ walk(); }
 
This would then make it possible for a species to EAT, SLEEP and for example FLY.
A species would be a combination of ROLES, instead of being characterized as an ANIMAL.
At a larger scale, MICROSERVICES are a very similar case, they are pieces of a system separated by RESPONSIBILITIES, instead of being a great MONOLITH.

##############################################################################
D	-> Dependency Inversion Principle

##############################################################################