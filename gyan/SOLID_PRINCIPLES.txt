	|\
====| \
		S	-> Single Responsibility Principle
====| /	
	|/
	
	|\
====| \
		O	-> Open / Closed Principle
====| /	
	|/
	
	|\
====| \
		L	-> Liskov Substitution Principle 
====| /	
	|/
	
	|\
====| \
		I	-> Interface Segregation Principle
====| /	
	|/
	
	|\
====| \
		D	-> Dependency Inversion Principle
====| /	
	|/
	
/***********************	S O L I D  hai Boss		************************/

S	-> Single Responsibility Principle

In object-oriented computer programming, the term SOLID is a mnemonic acronym for five design principles intended to make software designs more understandable, flexible and maintainable. The principles are a subset of many principles promoted by Robert C. Martin.
Though they apply to any object-oriented design, the SOLID principles can also form a core philosophy for methodologies such as agile development or adaptive software development

SOLID stands for 

Single responsibility principle
a class should have only a single responsibility (i.e. changes to only one part of the software's specification should be able to affect the specification of the class).
Open/closed principle
"software entities … should be open for extension, but closed for modification."
Liskov substitution principle
"objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program." See also design by contract.
Interface segregation principle
"many client-specific interfaces are better than one general-purpose interface."
Dependency inversion principle
one should "depend upon abstractions, [not] concretions."


Single responsibility principle
The single responsibility principle is a computer programming principle that states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility. Robert C. Martin expresses the principle as, "A class should have only one reason to change."
The term was introduced by Robert C. Martin in an article by the same name as part of his Principles of Object Oriented Design,[2] made popular by his book Agile Software Development, Principles, Patterns, and Practices. Martin described it as being based on the principle of cohesion.

Martin defines a responsibility as a reason to change, and concludes that a class or module should have one, and only one, reason to be changed (i.e. rewritten). As an example, consider a module that compiles and prints a report. Imagine such a module can be changed for two reasons. First, the content of the report could change. Second, the format of the report could change. These two things change for very different causes; one substantive, and one cosmetic. The single responsibility principle says that these two aspects of the problem are really two separate responsibilities, and should therefore be in separate classes or modules. It would be a bad design to couple two things that change for different reasons at different times.

##############################################################################
O	-> Open / Closed Principle

Simple theory of Open/Closed principle state Class should be open for extention and closed for modification.

A class is closed, since it may be compiled, stored in a library, baselined, and used by client classes. But it is also open, since any new class may use it as parent, adding new features. When a descendant class is defined, there is no need to change the original or to disturb its clients.

Example :
--------

Let’s say that we’ve got a Rectangle class. As most rectangles that I’ve encountered it has a width and a height.

public class Rectangle
{
    public double Width { get; set; }
    public double Height { get; set; }
}

Now our client wants us to build an application that can calculate the total area of a collection of rectangles.

That’s not a problem for us. We learned in school that the area of a rectangle is it’s width multiplied with it’s height and we mastered the for-each-loop a long time ago.
public class AreaCalculator
{
    public double Area(Rectangle[] shapes)
    {
        double area = 0;
        foreach (var shape in shapes)
        {
            area += shape.Width*shape.Height;
        }

        return area;
    }
}

We present our solution, the AreaCalculator class to client and they signs us his praise. But he also wonders if we couldn’t extend it so that it could calculate the area of not only rectangles but of circles as well.
That complicates things a bit but after some pondering we come up with a solution where we change our Area method to accept a collection of objects instead of the more specific Rectangle type. Then we check what type each object is of and finally cast it to it’s type and calculate it’s area using the correct algorithm for the type.

public double Area(object[] shapes)
{
    double area = 0;
    foreach (var shape in shapes)
    {
        if (shape is Rectangle)
        {
            Rectangle rectangle = (Rectangle) shape;
            area += rectangle.Width*rectangle.Height;
        }
        else
        {
            Circle circle = (Circle)shape;
            area += circle.Radius * circle.Radius * Math.PI;
        }
    }

    return area;
}

The solution works and client is happy.

Only, a week later he calls us and asks: “extending the AreaCalculator class to also calculate the area of triangles isn’t very hard, is it?”. Of course in this very basic scenario it isn’t but it does require us to modify the code. That is, AreaCalculator isn’t closed for modification as we need to change it in order to extend it. Or in other words: it isn’t open for extension.

In a real world scenario where the code base is ten, a hundred or a thousand times larger and modifying the class means redeploying it’s assembly/package to five different servers that can be a pretty big problem. Oh, and in the real world Aldford would have changed the requirements five more times since you read the last sentence :-)

A solution that abides by the Open/Closed Principle
+++++++++++++++++++++++++++++++++++++++++++++++++++

One way of solving this puzzle would be to create a base class for both rectangles and circles as well as any other shapes that client can think of which defines an abstract method for calculating it’s area.
public abstract class Shape
{
    public abstract double Area();
}

Inheriting from Shape the Rectangle and Circle classes now looks like this:
public class Rectangle extends Shape
{
    public double Width { get; set; }
    public double Height { get; set; }
    public override double Area()
    {
        return Width*Height;
    }
}

public class Circle extends Shape
{
    public double Radius { get; set; }
    public override double Area()
    {
        return Radius*Radius*Math.PI;
    }
}

As we’ve moved the responsibility of actually calculating the area away from AreaCalculator’s Area method it is now much simpler and robust as it can handle any type of Shape that we throw at it.

public double Area(Shape[] shapes)
{
    double area = 0;
    foreach (var shape in shapes)
    {
        area += shape.Area();
    }

    return area;
}

##############################################################################
L	-> Liskov Substitution Principle 



##############################################################################
I	-> Interface Segregation Principle

* Make fine grained interfaces that are client 
* Client should not be forced to implement interfaces that they do not use
* In other words, its better to have smaller interfaces, than fewer, fatter interface
* By breaking down interfaces, we are favor COMPOSITION instead of INHERITANCE
* Decoupling over Coupling

Ex : 
Interface Segregation NOT Applied
---------------------------------
interface Animal {
	eat();
	sleep();
	walk();
}

This would mean that we have a MONOLTHIC interface called ANIMAL, 
which would NOT be the perfect ABSTRACTION, because some animals can FLY.

Interface Segregation APPLIED
-----------------------------
Breaking this monolithic interface into smaller interfaced based by ROLE.
 
interface CanEat	{ eat(); } 
interface CanSleep	{ sleep(); } 
interface CanWalk	{ walk(); }
 
This would then make it possible for a species to EAT, SLEEP and for example FLY.
A species would be a combination of ROLES, instead of being characterized as an ANIMAL.
At a larger scale, MICROSERVICES are a very similar case, they are pieces of a system separated by RESPONSIBILITIES, instead of being a great MONOLITH.

##############################################################################
D	-> Dependency Inversion Principle

##############################################################################
